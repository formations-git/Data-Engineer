<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Guide ‚Äî Entit√©s LookML (connection, model, views, explores, fields, sets, drill_fields)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
  <script>hljs.highlightAll();</script>
  <style>
    /* Reprend le style du guide original */
    body { font-family: Inter, Roboto, Arial; max-width: 980px; margin: 28px auto; padding: 20px; line-height: 1.55; color: #f1f1f1; background: #0b1d3a; }
    h1,h2 { color: #f8f8f2; }
    pre { background-color: transparent !important; padding: 0 !important; border-radius: 0 !important; overflow-x: auto; margin: 12px 0; }
    .hljs { background-color: #033466 !important; padding: 10px !important; border-radius: 4px !important; }
    code { font-family: Consolas, Monaco, monospace; font-size: 14px; color: #f8f8f2; }
    p, li { color: #cccccc; }
    .hint { background: #163d66; border-left: 4px solid #4da6ff; padding: 12px; margin: 12px 0; border-radius: 6px; color: #fff; }
    .section { margin-bottom: 20px; }
    ul { margin-left: 1.25em; }
    .small { font-size: 90%; color: #bfcbdc; }
    table { width: 100%; border-collapse: collapse; margin: 12px 0; }
    th, td { border: 1px solid rgba(255,255,255,0.08); padding: 8px; text-align: left; }
    th { background: rgba(255,255,255,0.04); }
    .kbd { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 4px; font-family: monospace; }
    .note { color: #a8d1ff; font-size: 95%; }
    .cta { margin-top: 14px; }
  </style>
</head>
<body>
  <h1>Entit√©s LookML ‚Äî connexion, mod√®le, views, explores, fields, sets et drill_fields</h1>
  <p class="small">Page adapt√©e et enrichie √† partir d'un guide LookML orient√© BigQuery. Cette page explique chaque entit√© et fournit des exemples LookML r√©utilisables.</p>

  <div class="section">
    <h2>üîπ 1. Connection</h2>
    <p>D√©finie dans <strong>Admin &gt; Connexions</strong> (hors LookML). Le fichier <code>.model.lkml</code> r√©f√©rence cette connexion pour interroger la source de donn√©es.</p>
    <div class="hint">
      <pre><code class="language-bash"># Exemple dans un mod√®le
connection: "bigquery_hr_conn"</code></pre>
    </div>
  </div>

  <div class="section">
    <h2>üîπ 2. Model (fichier .model.lkml)</h2>
    <p>Fichier d'entr√©e du projet. On y d√©clare la <span class="kbd">connection</span>, les <span class="kbd">include</span> et les <span class="kbd">explore</span> expos√©s aux utilisateurs.</p>

    <div class="hint">
      <pre><code class="language-bash">connection: "my_database"
include: "*.view.lkml"
include: "*.explore.lkml"

explore: orders {
  label: "Commandes"
  join: customers
}
</code></pre>
    </div>

    <p class="note">Note¬†: adapte le nom de connexion au nom exact cr√©√© dans l'admin Looker (par ex. <em>bigquery_hr_conn</em>).</p>
  </div>

  <div class="section">
    <h2>üîπ 3. View (fichier .view.lkml)</h2>
    <p>Une <strong>view</strong> repr√©sente g√©n√©ralement une table SQL et d√©finit les dimensions, measures et √©ventuellement des sets.</p>

    <div class="hint">
      <pre><code class="language-bash">view: orders {
  sql_table_name: `schema.orders` ;;

  dimension: order_id {
    primary_key: yes
    type: number
    sql: ${TABLE}.order_id ;;
  }

  dimension: order_date {
    type: date
    sql: ${TABLE}.order_date ;;
  }

  measure: total_revenue {
    type: sum
    sql: ${TABLE}.order_total ;;
  }

  # Exemple de set dans la view
  set: summary_fields {
    fields: [order_date, total_revenue]
  }
}
</code></pre>
    </div>
  </div>

  <div class="section">
    <h2>üîπ 4. Explore</h2>
    <p>Point d'acc√®s utilisateur qui d√©finit une view principale et des joins vers d'autres views.</p>

    <div class="hint">
      <pre><code class="language-bash">explore: orders {
  join: customers {
    type: left_outer
    sql_on: ${orders.customer_id} = ${customers.id} ;;
  }

  # Restreindre les champs expos√©s dans l'explore
  fields: [orders.order_date, orders.total_revenue, customers.name]
}
</code></pre>
    </div>
  </div>

<div class="section">
<h2>üîπ 5. Dimensions / measures / parameters</h2>
<ul>
<li><strong>Dimensions</strong> ‚Üí champs de d√©tail (ex. id, nom, date, cat√©gorie)</li>
<li><strong>Measures</strong> ‚Üí agr√©gats calcul√©s (ex. count, sum, average)</li>
<li><strong>Parameters</strong> ‚Üí variables d√©finies par l'utilisateur (ex. choisir une m√©trique √† afficher)</li>
</ul>

<div class="hint">
<pre><code class="language-bash">view: employees {
sql_table_name: `my_dataset.employees` ;;


dimension: employee_id {
primary_key: yes
type: number
sql: ${TABLE}.employee_id ;;
}


dimension: full_name {
type: string
sql: CONCAT(${TABLE}.first_name, " ", ${TABLE}.last_name) ;;
description: "Nom complet de l'employ√©"
}


dimension: hire_date {
type: date
sql: ${TABLE}.hire_date ;;
}


measure: count {
type: count
description: "Nombre d'employ√©s"
}


measure: avg_salary {
type: average
sql: ${TABLE}.salary ;;
description: "Salaire moyen"
}


parameter: salary_tier {
type: unquoted
allowed_value: { label: "Junior" value: "&lt; 3000" }
allowed_value: { label: "Senior" value: "&gt;= 3000" }
description: "Classification selon le salaire"
}
}
</code></pre>
</div>


<p class="note">Les dimensions/mesures apparaissent comme champs dans l'interface Explore. Les parameters servent √† rendre un champ interactif ou configurable.</p>
</div>


<div class="section">
<h2>üîπ 6. Joins</h2>
<p>Un <strong>join</strong> permet de relier deux views. Il est d√©fini dans un <code>explore</code> et doit pr√©ciser :</p>
	<ul>
		<li>le type de jointure (<span class="kbd">left_outer</span>, <span class="kbd">inner</span>, etc.)</li>
		<li>la relation (<span class="kbd">one_to_many</span>, <span class="kbd">many_to_one</span>)</li>
		<li>la condition (<code>sql_on</code>)</li>
	</ul>

	<div class="hint">
	<pre><code class="language-bash">explore: employees {
	join: departments {
	type: left_outer
	relationship: many_to_one
	sql_on: ${employees.department_id} = ${departments.department_id} ;;
	}


	join: jobs {
	type: left_outer
	relationship: many_to_one
	sql_on: ${employees.job_id} = ${jobs.job_id} ;;
	}
		</code></pre>
    </div>
</div>

<div class="section">
 <h2>üîπ 7. Include / Set</h2>
    <p><strong>Include</strong> : organise le code en fichiers. <strong>Set</strong> : regroupe des champs pour une utilisation m√©tier.</p>
 </div>
    <div class="hint">
      <pre><code class="language-bash"># include dans un .model.lkml
		include: "orders.view.lkml"
		include: "customers.view.lkml"

		# set dans une view
		view: orders {
		  set: default_fields {
			fields: [order_id, total_revenue, customers.name]
		  }
		}
		</code></pre>
    </div>


<h2>7.1 include ‚Äî R√¥le et utilisation</h2>
<p><strong>üëâ R√¥le</strong><br>
Sert √† modulariser le code LookML en incluant d‚Äôautres fichiers. Permet de structurer un projet LookML en plusieurs fichiers (<code>.view.lkml</code>, <code>.explore.lkml</code>, <code>.model.lkml</code>, etc.). Fonctionne comme un import dans d‚Äôautres langages.</p>


<p><strong>üëâ Utilisation</strong><br>
Dans un fichier <code>.model.lkml</code> :</p>
<div class="hint">
<pre><code>include: "*.view" # inclut toutes les views\include: "orders.view" # inclut uniquement le fichier des commandes
include: "*.explore" # inclut tous les explores</code></pre>
</div>


<p>‚û°Ô∏è Typiquement, un projet LookML bien organis√© :</p>
<ul>
<li><code>ecommerce.model.lkml</code> (mod√®le principal)</li>
<li><code>orders.view.lkml</code></li>
<li><code>customers.view.lkml</code></li>
<li><code>products.view.lkml</code></li>
</ul>
<p>Gr√¢ce aux <code>include</code>, le fichier mod√®le ¬´¬†voit¬†¬ª les d√©finitions de toutes les views/explores.</p>


<h2>7.2 set ‚Äî R√¥le et utilisation</h2>
<p><strong>üëâ R√¥le</strong><br>
Sert √† grouper des champs (dimensions, mesures, voire filtres) pour simplifier l‚Äôexploration. On peut ensuite utiliser ces sets dans les explores ou dans des restrictions (<code>always_filter</code>, <code>fields</code>, etc.). C‚Äôest un m√©canisme m√©tier (contrairement √† <code>include</code> qui est purement technique).</p>


<p><strong>üëâ Utilisation</strong><br>
D√©finition d‚Äôun set dans une view¬†:</p>
<div class="hint">
<pre><code>view: orders {
dimension: order_id { type: number sql: ${TABLE}.id ;; }
dimension: order_date { type: date sql: ${TABLE}.date ;; }
measure: total_revenue { type: sum sql: ${TABLE}.amount ;; }
measure: count_orders { type: count ;; }


set: summary_fields {
fields: [order_date, total_revenue, count_orders]
}
}
</code></pre>
</div>

<p><strong>üëâ R√©utilisation dans un explore :</strong></p>
<div class="hint">
<pre><code>
explore: orders {
fields: [summary_fields] # rend disponibles uniquement ces champs
}</code></pre>
</div>

<h3>üîπ Comparaison rapide</h3>
<section class="hint"> 
<div class="table-like">
<table>
<tr><th>√âl√©ment</th><th>Objectif</th><th>Niveau</th><th>Exemple typique</th></tr>
<tr><td>include</td><td>Modulariser et importer du code</td><td>Organisation technique du projet</td><td><code>include: "*.view"</code></td></tr>
<tr><td>set</td><td>Grouper des champs pour simplifier ou restreindre l‚Äôexploration</td><td>Fonctionnel (m√©tier)</td><td><code>set: summary_fields { fields: [order_date, total_revenue] }</code></td></tr>
</table>
</div>
</section>

<h3>üîπ Cas d‚Äôusage typiques</h3>
<section class="hint"> 
<ul>
<li><strong>‚úÖ include</strong> : Projet complexe avec 20+ tables ‚Üí chaque table dans son propre fichier .view.lkml, puis inclus dans le mod√®le.</li>
<li><strong>‚úÖ set</strong> : Cr√©er une version "light" d‚Äôun explore avec seulement les champs principaux, ou limiter les champs visibles selon le r√¥le utilisateur.</li>
</ul>
</section>

  <div class="section">
    <h2>üîπ 8 fields et drill_fields</h2>
    <p><strong>fields</strong> : d√©termine les champs visibles dans un explore (niveau macro).<br>
    <strong>drill_fields</strong> : champs affich√©s lorsque l'utilisateur clique (drill) sur une cellule (niveau micro).</p>

<section class="hint"> 
    <table>
      <thead>
        <tr><th>√âl√©ment</th><th>Quand ?</th><th>Ce que √ßa fait</th><th>Exemple</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>fields</td>
          <td>Avant / dans Explore</td>
          <td>Restreint ou expose les champs visibles</td>
          <td><code>fields: [order_date, total_revenue]</code></td>
        </tr>
        <tr>
          <td>drill_fields</td>
          <td>Apr√®s / en drill</td>
          <td>D√©finit les champs d√©taill√©s affich√©s au clic</td>
          <td><code>drill_fields: [order_id, customer_name, product_name]</code></td>
        </tr>
      </tbody>
    </table>
</section> 

    <div class="hint">
      <pre><code class="language-bash">measure: total_revenue {
  type: sum
  sql: ${TABLE}.amount ;;
  drill_fields: [order_id, order_date, customers.name]
}
</code></pre>
    </div>
  </div>

  <div class="section">
    <h2>üîπ 8.1 Exemple interactif : fields vs drill_fields</h2>
    <p>Sc√©nario : <em>explore: orders</em> expose seulement deux champs via <code>fields</code>. Le <code>measure</code> total_revenue a des <code>drill_fields</code> d√©finis.</p>

    <div class="hint">
      <pre><code class="language-bash">
measure: total_revenue {
  type: sum
  sql: ${TABLE}.amount ;;
  drill_fields: [order_id, customer_name, product_name]
}

explore: orders {
  fields: [orders.order_date, orders.total_revenue]
}
</code></pre>
    </div>

    <p class="note">Exemple visuel (r√©sultats d'explore) :</p>
    <table>
      <thead>
        <tr><th>Order Date</th><th>Total Revenue</th></tr>
      </thead>
      <tbody>
        <tr><td>2025-09-01</td><td>1 250 ‚Ç¨</td></tr>
        <tr><td>2025-09-02</td><td>980 ‚Ç¨</td></tr>
        <tr><td>2025-09-03</td><td>1 540 ‚Ç¨</td></tr>
      </tbody>
    </table>

    <p class="note">Apr√®s clic (drill) sur <em>1 250 ‚Ç¨</em>, Looker affiche la vue d√©taill√©e suivante (selon <code>drill_fields</code>) :</p>
    <table>
      <thead>
        <tr><th>Order ID</th><th>Customer Name</th><th>Product Name</th><th>Amount</th></tr>
      </thead>
      <tbody>
        <tr><td>10123</td><td>Alice Dupont</td><td>Laptop</td><td>850 ‚Ç¨</td></tr>
        <tr><td>10124</td><td>Marc Petit</td><td>Mouse</td><td>30 ‚Ç¨</td></tr>
        <tr><td>10125</td><td>Julie Martin</td><td>Monitor</td><td>370 ‚Ç¨</td></tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>üîπ En r√©sum√©</h2>
    <p>fields = ce que l'on voit dans l'explore (macro).<br>
    drill_fields = ce que l'on voit quand on creuse une cellule (micro). cel√† √©vite d'exposer trop de champs en explore tout en proposant une vue d√©taill√©e au clic</p>
  </div>

</body>
</html>
