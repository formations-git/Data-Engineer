<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <title>Concepts cl√©s BigQuery : Cl√© primaire, partitionnement et clustering</title>
    <!-- Int√©gration du style et script Highlight.js avec th√®me fonc√© -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/sql.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: Inter, Roboto, Arial; 
            max-width: 980px;                 
            margin: 28px auto;                
            padding: 20px;                    
            line-height: 1.55;                
            color: #f1f1f1;                   
            background: #0b1d3a;              
        }
        h1, h2, h3 {
            color: #f8f8f2;
        }
        pre {
            background-color: transparent !important;
            padding: 0 !important;
            border-radius: 0 !important;
            overflow-x: auto;
        }
        .hljs {
            background-color: #033466 !important; 
            padding: 10px !important;
            border-radius: 4px !important;
            font-size: 14px;
        }
        code {
            font-family: Consolas, Monaco, monospace;
            font-size: 14px;
            color: #f8f8f2;
        }
        p, li {
            color: #cccccc;
        }
        ul {
            padding-left: 20px;
        }
        section {
            margin-bottom: 30px;
        }
        .hint {
            background: #163d66;            
            border-left: 4px solid #4da6ff; 
            padding: 12px;                  
            margin: 12px 0;                 
            border-radius: 6px;             
            color: #fff;                    
        }
        .hint2 {
            background: #166627;            
            border-left: 4px solid #4dff4d; 
            padding: 12px;                  
            margin: 12px 0;                 
            border-radius: 6px;             
            color: #fff;                    
        }
        .hint3 {
            background: #023266;            
            border-left: 4px solid #4da6ff; 
            padding: 12px;                  
            margin: 12px 0;                 
            border-radius: 6px;             
            color: #fff;                    
        }
        table {
            border-collapse: collapse;
            margin-top: 16px;
            width: 100%;
        }
        th, td {
            border: 1px solid #4da6ff;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #163d66;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <h1>Concepts cl√©s BigQuery : Cl√© primaire, partitionnement et clustering</h1>

    <section>
        <h2>1. Cl√© primaire (Primary Key)</h2>
        <p>En bases relationnelles classiques (ex : PostgreSQL, MySQL), une cl√© primaire est un identifiant unique et obligatoire pour chaque ligne.</p>
        <p><strong>Dans BigQuery :</strong></p>
        <ul>
            <li>BigQuery ne force pas les contraintes d‚Äôint√©grit√© comme les cl√©s primaires.</li>
            <li>Tu peux d√©signer une colonne comme identifiant logique (par exemple user_id, transaction_id), mais BigQuery n‚Äôemp√™che pas les doublons.</li>
            <li>C‚Äôest √† toi (via ETL/ELT ou requ√™tes SQL) de t‚Äôassurer que cette cl√© reste unique.</li>
        </ul>
        <div class="hint">
            üëâ Exemple :
            <pre><code class="sql">
SELECT user_id, COUNT(*) 
FROM `projet.dataset.utilisateurs`
GROUP BY user_id
HAVING COUNT(*) > 1;
            </code></pre>
            ‚Üí V√©rifie si ta "cl√© primaire" logique (user_id) est bien unique.
        </div>
        <section class="hint2">
        <h3>Comportement BigQuery avec / sans cl√© primaire</h3>
        <ul>
            <li><strong>Avec cl√© primaire :</strong> unicit√© logique g√©r√©e par toi, pas de gain de performance.</li>
            <li><strong>Sans cl√© primaire :</strong> aucun impact performance, mais risque de doublons incoh√©rents.</li>
        </ul>
        <p>üëâ Conclusion : Cl√© primaire = contrainte organisationnelle, pas technique.</p>
        </section>
    </section>

    <section>
        <h2>2. Cl√©s √©trang√®res (Foreign Keys)</h2>
        <p>Dans une BD relationnelle, une cl√© √©trang√®re garantit qu‚Äôune valeur existe d√©j√† dans une autre table (r√©f√©rence).</p>
        <p><strong>Dans BigQuery :</strong></p>
        <ul>
            <li>Pas de contrainte automatique de cl√© √©trang√®re.</li>
            <li>Tu peux tout de m√™me utiliser la relation en faisant un <code>JOIN</code> entre tables.</li>
            <li>Tu dois g√©rer toi-m√™me la coh√©rence entre tables r√©f√©renc√©es.</li>
        </ul>
        <div class="hint">
            üëâ Exemple :
            <pre><code class="sql">
SELECT u.user_id, u.nom, t.transaction_id
FROM `projet.dataset.utilisateurs` u
LEFT JOIN `projet.dataset.transactions` t
ON u.user_id = t.user_id;
            </code></pre>
            Ici <code>transactions.user_id</code> est conceptuellement une cl√© √©trang√®re vers <code>utilisateurs.user_id</code>.
        </div>
        <section class="hint2">
        <h3>Comportement BigQuery avec / sans cl√© √©trang√®re</h3>
        <ul>
            <li><strong>Avec cl√© √©trang√®re :</strong> relation logique via JOIN, mais pas d‚Äôint√©grit√© garantie, JOIN parfois co√ªteux.</li>
            <li><strong>Sans cl√© √©trang√®re :</strong> pas d‚Äôerreur technique, mais risque de donn√©es orphelines.</li>
        </ul>
        <p>üëâ Conclusion : Cl√©s √©trang√®res = seulement conceptuelles.</p>
        </section>
    </section>

    <section>
        <h2>3. Partitionnement (Partitioning)</h2>
        <p>Le partitionnement est une m√©thode pour diviser une table en morceaux logiques (partitions).</p>
        <p><strong>Dans BigQuery :</strong></p>
        <ul>
            <li>Partitionnement par date/temps ‚Üí avec colonne DATE, DATETIME ou TIMESTAMP.</li>
            <li>Partitionnement par entier ‚Üí bas√© sur une colonne enti√®re.</li>
            <li>Partitionnement auto ingestion ‚Üí via <code>_PARTITIONTIME</code>.</li>
        </ul>
        <div class="hint">
            üëâ Exemple :
            <pre><code class="sql">
CREATE TABLE `projet.dataset.logs` (
  user_id STRING,
  event_time TIMESTAMP,
  action STRING
)
PARTITION BY DATE(event_time);
            </code></pre>
        </div>
        <section class="hint2">
        <h3>Comportement BigQuery avec / sans partitionnement</h3>
        <ul>
            <li><strong>Avec partitionnement :</strong> seule une partie de la table est scann√©e ‚Üí co√ªt r√©duit, meilleure performance.</li>
            <li><strong>Sans partitionnement :</strong> BigQuery scanne toute la table ‚Üí co√ªteux et lent.</li>
        </ul>
        <p>üëâ Conclusion : Partitionnement = optimisation critique sur gros volumes.</p>
        </section>
    </section>

    <section>
        <h2>4. Segmentation (Sharding)</h2>
        <p>Sharding : consiste √† diviser une grande table en plusieurs sous-tables plus petites, souvent appel√©es shards. Avec un suffixe (logs_202309, logs_202310).</p>
        <p>Dans BigQuery, le sharding traditionnel se faisait via des tables avec suffixe de date, par exemple :logs_202309, logs_202310...</p>

        <div class="hint">
            üëâ Exemple : Tu peux interroger plusieurs shards en une seule requ√™te avec un wildcard :
            <pre><code class="sql">
SELECT * 
FROM `projet.dataset.logs_*`
WHERE _TABLE_SUFFIX BETWEEN '202309' AND '202310';
            </code></pre>
            üëâ _TABLE_SUFFIX contient la partie variable du nom du shard.
        </div>
        <p>üîπ Historique : </p>
        <ul><ul>
            üîπavant 2018, BigQuery recommandait le sharding pour g√©rer de tr√®s gros volumes, mais aujourd‚Äôhui, les tables partitionn√©es et cluster√©es sont pr√©f√©r√©es, car elles sont plus simples et optimis√©es.</li>
            <li>‚úÖ aujourd‚Äôhui : BigQuery recommande  de remplacer le sharding par une table partitionn√©e (par exemple date) et cluster√©e sur les colonnes de filtrage fr√©quentes.</li>
        </ul></ul>


    <section class="hint">
        <p><strong>Bonnes pratiques pour le sharding / segmentation</strong></p>
            <ul><ul>
                <li><strong>Limiter le nombre de shards par requ√™te</strong> (< 1 000).</li>
                <li><strong>Nommer les shards de mani√®re coh√©rente</strong>, id√©alement avec une dimension temporelle (YYYYMMDD).</li>
                <li><strong>Pr√©f√©rer le partitionnement si possible</strong> pour simplifier la gestion et r√©duire le co√ªt.</li>
                <li><strong>Combiner partitionnement + clustering </strong>: tu obtiens l‚Äô√©quivalent d‚Äôun sharding automatique + des scans optimis√©s par filtrage.</li>
            </ul></ul>
    </section> 

        <section class="hint2">
        <h3>Comportement BigQuery avec / sans segmentation</h3>
        <ul>
            <li><strong>Avec segmentation :</strong> d√©coupe manuelle possible, mais lourde √† g√©rer, moins efficace que le partitionnement.</li>
            <li><strong>Sans segmentation :</strong></li> 
                <ul>
                    <li>Table √©norme, difficile √† manipuler si pas partitionn√©e.</li>
                    <li><strong>Scan optimis√© par filtrage de shard:</strong></li>
                    <ul>
                        <li>BigQuery ne scanne que les shards n√©cessaires si tu utilises _TABLE_SUFFIX dans le filtre.</li>
                        <li>Cela r√©duit consid√©rablement le volume de donn√©es lues et donc le co√ªt.</li>
                    </ul>
                    <li><strong>Comportement de performance:</strong></li>
                    <ul>
                        <li>Chaque shard est trait√© comme une table ind√©pendante.</li>
                        <li>Trop de shards peuvent d√©grader les performances, car BigQuery cr√©e <strong>un plan de requ√™te pour chaque shard</strong> et les agr√®ge ensuite.</li>
                        <li>Google recommande de <strong>ne pas d√©passer 1 000 shards par requ√™te.</strong></li>
                    </ul>
                </ul>
        </ul>
        <p>üëâ Conclusion : Segmentation = solution h√©rit√©e, √† √©viter sauf cas pr√©cis.</p>
        </section>
    </section>

    <h2>5. Clustering</h2>
        <p>Le clustering regroupe physiquement les lignes selon les colonnes choisies (user_id, region...).</p>
        <p>Le clustering permet √† BigQuery de r√©organiser physiquement les donn√©es dans les tables en fonction de certaines colonnes pour acc√©l√©rer les requ√™tes filtrant sur ces colonnes.</p>
        <h3>Principes pour choisir les champs :</h3>
        <ul><ul>
            <li><strong>Choisir des colonnes souvent utilis√©es dans les filtres (WHERE) ou JOIN).</strong></li>
            <li><strong>Colonnes avec cardinalit√© moyenne :</strong></li>
            <ul>
                <li><strong>Trop faible ‚Üí </strong>peu d‚Äôefficacit√© (ex : bool√©en ou 0/1).</li>
                <li><strong>Trop √©lev√© ‚Üí </strong>BigQuery ne pourra pas regrouper efficacement (ex : ID unique).</li>
            </ul>
            <li><strong>Colonnes dans l‚Äôordre d‚Äôusage :</strong></li>
            <ul>
                <li>Le premier champ du clustering est celui sur lequel tu fais le plus souvent des filtres.</li>
                <li>Ensuite, tu peux ajouter des colonnes secondaires si tu filtres souvent sur plusieurs colonnes simultan√©ment.</li>
            </ul>

            <li><strong>Nombre de colonnes dans un cluster :</strong></li>
            <ul>
                <li><strong>Maximum : 4 colonnes par table.</strong></li>
                <li>L‚Äôordre des colonnes dans le clustering <strong>importe</strong>, car BigQuery trie les donn√©es en fonction de cet ordre.</li>
            </ul>

            <li><strong>Nombre de clusters par table :</strong></li>
            <ul>
                <li><strong>Une seule d√©finition de clustering par table.</strong></li>
                <li>Autrement dit, tu d√©finis <strong>jusqu‚Äô√† 4 colonnes pour un seul cluster</strong>, mais tu ne peux pas cr√©er plusieurs clusters distincts sur la m√™me table.</li>
            </ul>
            <li><strong>Notes pratiques:</strong></li>
                <ul>
                    <li>Le clustering est <strong>compatible avec le partitionnement</strong>, et c‚Äôest souvent recommand√© de partitionner d‚Äôabord (ex. par date) puis de clusterer sur les colonnes les plus filtr√©es.</li>
                    <li>Si tu as plus de colonnes filtr√©es fr√©quemment, tu dois <strong>prioriser les 4 plus importantes</strong> pour le clustering.</li>
                </ul>

        <section class="hint3">
            <ul><ul>
                <li><strong>Exemple :</strong></li>
                <p>Si tu as une table de transactions :</p>
                <ul>
                    <li><strong>event_date ‚Üí </strong>souvent filtr√©e dans WHERE pour des plages de temps</li>
                    <li><strong>user_id ‚Üí </strong>l'id souvent utilis√©e pour la jointure</li>
                    <li><strong>region ‚Üí </strong>souvent utilis√©e pour des rapports r√©gionaux</li>
                </ul>   
            </ul></ul>
        
            <div class="hint">
                üëâ Exemple :
                <pre><code class="sql">
                    CREATE TABLE `projet.dataset.transactions` (
                    transaction_id STRING,
                    user_id STRING,
                    region STRING,
                    amount FLOAT64,
                    event_date DATE
                    )
                    PARTITION BY event_date
                    CLUSTER BY user_id, region;
                </code></pre>
            </div>
            <p>üí° Astuce : Le clustering est plus efficace sur des tables tr√®s volumineuses et surtout si les requ√™tes filtrent sur ces colonnes.</p>
        </section>
        <section class="hint2">
            <h3>Comportement BigQuery avec / sans clustering</h3>
            <ul>
                <li><strong>Avec clustering :</strong> BigQuery lit moins de blocs de donn√©es, requ√™tes beaucoup plus rapides.</li>
                <li><strong>Sans clustering :</strong> scans complets m√™me avec filtres ‚Üí pertes de performance.</li>
            </ul>
            <p>üëâ Conclusion : Clustering = optimisation secondaire, utile sur tr√®s grands volumes.</p>
        </section>

        <section>
                <h2>‚úÖ R√©sum√© visuel</h2>
                <table>
                    <tr>
                        <th>Concept</th>
                        <th>Dans une BD classique</th>
                        <th>Dans BigQuery</th>
                    </tr>
                    <tr>
                        <td>Cl√© primaire</td>
                        <td>Unicit√© garantie</td>
                        <td>Pas de contrainte, √† g√©rer soi-m√™me</td>
                    </tr>
                    <tr>
                        <td>Cl√© √©trang√®re</td>
                        <td>R√©f√©rence forc√©e entre tables</td>
                        <td>Pas de contrainte, relation logique via JOIN</td>
                    </tr>
                    <tr>
                        <td>Partitionnement</td>
                        <td>D√©coupe physique de la table</td>
                        <td>Natif : par date, entier, ingestion</td>
                    </tr>
                    <tr>
                        <td>Segmentation</td>
                        <td>Peu courant (sauf sharding)</td>
                        <td>Tables multiples avec suffixes (<code>logs_202301</code>)</td>
                    </tr>
                    <tr>
                        <td>Clustering</td>
                        <td>Rare en OLTP, indexation</td>
                        <td>Regroupe physiquement selon colonnes pour optimiser</td>
                    </tr>
                </table>
            </section>
        <section>
 
            <section>
    <h2>6. Exemple d√©taill√© : Sharding, Partitionnement et Clustering pour un distributeur</h2>

    <section class="hint">
        <h3>1Ô∏è‚É£ Sharding</h3>
        <p><strong>D√©finition et r√¥le :</strong> Le sharding consiste √† s√©parer physiquement les donn√©es en plusieurs ensembles ind√©pendants, souvent pour des raisons d‚Äôisolation ou de distribution g√©ographique.</p>
        <p><strong>Exemple pour un distributeur :</strong></p>
        <ul>
            <li>Cr√©er un shard par pays : <code>sales_US</code>, <code>sales_FR</code>, <code>sales_DE</code>, etc.</li>
            <li>Permet d‚Äôisoler les donn√©es et de r√©duire la latence sur les requ√™tes par pays.</li>
            <li>Avantage : chaque shard peut √™tre g√©r√© et s√©curis√© ind√©pendamment.</li>
        </ul>
        <p>‚ö†Ô∏è Limitation : le sharding ne suffit pas pour g√©rer des milliards de lignes dans un m√™me pays. √Ä l‚Äôint√©rieur d‚Äôun shard, il faut des m√©canismes pour optimiser les requ√™tes massives.</p>
    </section>

    <section class="hint">
        <h3>2Ô∏è‚É£ Partitionnement (BigQuery)</h3>
        <p><strong>D√©finition :</strong> Le partitionnement divise une table logiquement en segments bas√©s sur une colonne, g√©n√©ralement pour faciliter les scans et optimiser les co√ªts.</p>
        <p><strong>Recommandations pour une table de ventes :</strong></p>
        <ul>
            <li><strong>Partitionnement par date :</strong>
                <ul>
                    <li>La colonne <code>sale_date</code> est id√©ale pour les tables de transactions.</li>
                    <li>Type : <code>DAY</code> (le plus courant), mais <code>MONTH</code> ou <code>YEAR</code> possible selon le volume.</li>
                    <li>Avantages : scan uniquement les partitions n√©cessaires ‚Üí r√©duction du co√ªt et du temps ; gestion plus simple des donn√©es anciennes (archivage / suppression).</li>
                </ul>
            </li>
            <li><strong>Partitionnement ingestion time :</strong> optionnel si les donn√©es sont ing√©r√©es r√©guli√®rement et que <code>sale_date</code> n‚Äôest pas fiable. BigQuery cr√©e automatiquement des partitions par date d‚Äôingestion.</li>
        </ul>
    </section>

    <section class="hint">
        <h3>3Ô∏è‚É£ Clustering (BigQuery)</h3>
        <p><strong>D√©finition :</strong> Le clustering trie physiquement les donn√©es √† l‚Äôint√©rieur d‚Äôune partition selon des colonnes fr√©quemment utilis√©es dans les filtres ou jointures.</p>
        <p><strong>Recommandations pour une table de ventes :</strong></p>
        <ul>
            <li>Colonnes fr√©quentes pour filtrer : <code>product_id</code>, <code>store_id</code> ou <code>region_id</code>, <code>customer_id</code> si analyses clients fr√©quentes.</li>
        </ul>
        <p><strong>Exemple BigQuery :</strong></p>
        <pre><code class="sql">
CREATE TABLE sales
PARTITION BY DATE(sale_date)
CLUSTER BY product_id, store_id
AS SELECT * FROM ...
        </code></pre>
        <p>Avantages : les scans sont beaucoup plus efficaces sur les colonnes filtr√©es ; moins de co√ªt de requ√™te car BigQuery peut sauter les blocs non pertinents.</p>
    </section>

    <section class="hint2">
        <h3>4Ô∏è‚É£ Strat√©gie globale pour des milliards de lignes</h3>
        <table>
            <tr>
                <th>Niveau</th>
                <th>Technique</th>
                <th>Exemple / choix</th>
                <th>Commentaire</th>
            </tr>
            <tr>
                <td>Global</td>
                <td>Sharding</td>
                <td>Par pays</td>
                <td>Isolation des donn√©es, conformit√© locale (RGPD, etc.)</td>
            </tr>
            <tr>
                <td>Par shard</td>
                <td>Partitionnement</td>
                <td>Par <code>sale_date</code> (DAY)</td>
                <td>Optimise les scans sur les plages de dates</td>
            </tr>
            <tr>
                <td>Par partition</td>
                <td>Clustering</td>
                <td><code>product_id, store_id</code></td>
                <td>Optimise les filtres et jointures fr√©quentes</td>
            </tr>
        </table>
        <p>üí° Astuce : tu peux combiner le partitionnement et le clustering dans BigQuery. Le partitionnement r√©duit le volume global scann√©, et le clustering acc√©l√®re les scans √† l‚Äôint√©rieur de la partition.</p>
    </section>

</section>

                

</body>
</html>
