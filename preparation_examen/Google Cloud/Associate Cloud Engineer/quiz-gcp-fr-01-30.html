
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Google Cloud - Associate Cloud Engineer Practice Exam</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f2f4f8;
            color: #333;
            max-width: 700px;
            margin: 30px auto;
            padding: 20px;
        }

        h2 {
            text-align: center;
            color: #2c3e50;
        }

        .question {
            background-color: #fff;
            padding: 15px 20px;
            margin-bottom: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s, background-color 0.3s;
        }

        .question:hover {
            transform: scale(1.02);
        }

        .question.incorrecte {
            background-color: #f8d7da;
        }

        .question p {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .option input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
        }

        .option.bonne-reponse {
            background-color: #d4edda;
        }

        .option.mauvaise-reponse {
            background-color: #f8d7da;
        }

        button {
            display: block;
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px auto;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .result {
            margin-top: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
        }

        .navigation {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .nav-btn {
            display: inline-block;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            padding: 10px 10px;
            border-radius: 5px;
            font-size: 1em;
            transition: background-color 0.3s;
        }

        .nav-btn:hover {
            background-color: #2980b9;
        }

        .explication {
            white-space: pre-wrap;
            background-color: #eef3f7;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 10px;
            display: none;
        }

        .question img {
            max-width: 100%;
            margin-top: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<h2>Quiz : Google Cloud - Associate Cloud Engineer Practice Exam</h2>

<form id="quizForm"></form>

<button type="button" onclick="verifier()">Valider</button>

<div id="resultat" class="result"></div>

<script>
const questions = [
    {
        id: 1,
        texte: `Question 1:
		Un ingénieur cloud associé utilise Cloud Shell. Quelle est la description correcte du comportement de persistance de Cloud Shell ?`,
        reponses: [
            { texte: "Cloud Shell fournit un répertoire personnel persistant de 5 Go qui reste disponible entre les sessions.", valeur: "correcte" },
            { texte: "Les instances Cloud Shell persistent indéfiniment jusqu'à ce qu'elles soient arrêtées manuellement.", valeur: "mauvaise" },
            { texte: "Les instances Cloud Shell sont éphémères et toutes les modifications, y compris celles du répertoire personnel, sont perdues après chaque session.", valeur: "mauvaise" },
            { texte: "Cloud Shell fournit un répertoire personnel persistant de 1 Go qui reste disponible entre les sessions.", valeur: "mauvaise" }
        ],
        containerId: "reponses1",
        explication: `Cloud Shell fournit un répertoire personnel persistant de 5 Go qui reste disponible entre les sessions. → Correct. 
	Cloud Shell offre aux utilisateurs un répertoire personnel persistant de 5 Go stocké dans Google Cloud Storage. Cela permet de conserver les fichiers d'une session à l'autre.

Les instances Cloud Shell sont éphémères et toutes les modifications, y compris celles du répertoire personnel, sont perdues après chaque session. → Incorrect. 
	Bien que les instances soient éphémères et se terminent automatiquement après une heure d'inactivité, le répertoire personnel est persistant et bénéficie d'une allocation de 5 Go.

Cloud Shell fournit un répertoire personnel persistant de 1 Go qui reste disponible entre les sessions. → Incorrect. 
	L'allocation est de 5 Go, pas 1 Go.

Les instances Cloud Shell persistent indéfiniment jusqu'à ce qu'elles soient arrêtées manuellement. → Incorrect. 
	Les sessions sont éphémères et se terminent après une heure d'inactivité.`
    },
    {
        id: 2,
        texte: `Question 2: 
		En tant qu'ingénieur cloud, vous devez créer une application nécessitant un grand volume de données entrantes sur une longue période. L'application est hébergée sur une instance Compute Engine et vous souhaitez optimiser les coûts et les performances. Quelle stratégie devez-vous adopter pour réserver une adresse IP interne pour cette tâche ?`,
        reponses: [
            { texte: "Associer une adresse IP interne statique régionale et activer le peering direct (Direct Peering).", valeur: "correcte" },
            { texte: "Attribuer plusieurs adresses IP internes éphémères pour répartir la charge.", valeur: "mauvaise" },
            { texte: "Associer uniquement une adresse IP interne éphémère à l'instance.", valeur: "mauvaise" },
            { texte: "Associer uniquement une adresse IP interne statique à l'instance.", valeur: "mauvaise" }
        ],
        containerId: "reponses2",
        explication: `Associer une adresse IP interne statique régionale et activer le peering direct (Direct Peering). → Correct.
Cette approche permet des transferts de données volumineux directement vers et depuis le réseau de Google, réduisant ainsi les coûts et la latence.

Associer uniquement une adresse IP interne statique à l'instance. → Incorrect.
Cela ne suffit pas pour optimiser les coûts et les performances dans ce cas d'utilisation.

Associer uniquement une adresse IP interne éphémère à l'instance. → Incorrect.
Les adresses IP éphémères peuvent changer si l'instance est arrêtée et redémarrée, ce qui n'est pas idéal.

Attribuer plusieurs adresses IP internes éphémères pour répartir la charge. → Incorrect.
Ce n'est pas possible. Dans GCP, vous ne pouvez attribuer qu'une seule adresse IP interne par interface réseau, avec un maximum de 8 interfaces par instance.`
    },
    {
        id: 3,
        texte: `Question 3: 
		Vous travaillez sur un projet Google Kubernetes Engine (GKE) et devez mettre à jour la version de Kubernetes dans les pools de nœuds. Vous souhaitez minimiser les perturbations des applications en fonctionnement pendant ce processus. Quelle stratégie devez-vous appliquer ?`,
        reponses: [
            { texte: "Créer un nouveau pool de nœuds avec la version de Kubernetes souhaitée et migrer les charges progressivement.", valeur: "correcte" },
            { texte: "Arrêter manuellement tous les pods avant d'effectuer la mise à jour.", valeur: "mauvaise" },
            { texte: "Utiliser des mises à jour progressives en réglant le paramètre maxUnavailable à une valeur élevée.", valeur: "mauvaise" },
            { texte: "Ne rien changer et s'appuyer sur les mises à jour automatiques fournies par GKE.", valeur: "mauvaise" }
        ],
        containerId: "reponses3",
        explication: `Créer un nouveau pool de nœuds avec la version de Kubernetes souhaitée et migrer les charges progressivement. → Correct.
Cette méthode vous permet de tester les charges de travail avec la nouvelle version sans perturber les applications existantes. Une fois vérifié, vous pouvez migrer progressivement les charges.

Arrêter manuellement tous les pods avant d'effectuer la mise à jour. → Incorrect.
Cela provoquerait une interruption des applications, ce qui est contraire aux bonnes pratiques.

Utiliser des mises à jour progressives en réglant le paramètre maxUnavailable à une valeur élevée. → Incorrect.
Cela risquerait de perturber les applications, car trop de pods pourraient devenir indisponibles en même temps.

Ne rien changer et s'appuyer sur les mises à jour automatiques fournies par GKE. → Incorrect.
Les mises à jour automatiques peuvent être imprévisibles et entraîner des interruptions. Une mise à jour contrôlée et progressive est préférable.`
    },
    {
        id: 4,
        texte: `Question 4: 
		En tant qu'ingénieur associé, vous devez gérer une instance Compute Engine devant être configurée pour redémarrer automatiquement si elle devient inopérante en raison d'erreurs système. Quelle configuration devez-vous sélectionner pour l'instance ?`,
        reponses: [
            { texte: `Activer l'option "Redémarrage automatique" de l'instance.`, valeur: "correcte" },
            { texte: `Définir l'option "Maintenance de l'hôte" de l'instance sur "Terminer l'instance".`, valeur: "mauvaise" },
            { texte: `Activer l'option "Protection contre la suppression" de l'instance.`, valeur: "mauvaise" },
            { texte: `Activer l'option "Prémemption" de l'instance.`, valeur: "mauvaise" }
        ],
        containerId: "reponses1",
        explication: `Activer l'option "Redémarrage automatique" de l'instance → Correct. Si cette option est activée, Compute Engine redémarre automatiquement l'instance en cas de panne système.

Définir l'option "Maintenance de l'hôte" sur "Terminer l'instance" → Incorrect. Cela concerne uniquement la maintenance du matériel physique, pas les erreurs système de l'instance.

Activer l'option "Prémemption" → Incorrect. Cela rend l'instance préemptible, c'est-à-dire sujette à être arrêtée par Google en cas de besoin de ressources, sans rapport avec les redémarrages automatiques.

Activer l'option "Protection contre la suppression" → Incorrect. Cela empêche la suppression de l'instance, mais ne gère pas son redémarrage automatique.`
    }
		// Ajoute les autres questions avec leurs explications ici...
];

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function afficherQuestions() {
    const form = document.getElementById('quizForm');
    form.innerHTML = '';

    questions.forEach(q => {
        const divQuestion = document.createElement('div');
        divQuestion.className = 'question';
        divQuestion.id = 'question' + q.id;

        const pQuestion = document.createElement('p');
        pQuestion.textContent = q.texte;
        divQuestion.appendChild(pQuestion);

        if (q.image) {
            const img = document.createElement('img');
            img.src = q.image;
            img.alt = 'Illustration';
            divQuestion.appendChild(img);
        }

        const divReponses = document.createElement('div');
        divReponses.id = q.containerId;

        const reponsesMelangees = [...q.reponses];
        shuffle(reponsesMelangees);

        reponsesMelangees.forEach(rep => {
            const label = document.createElement('label');
            label.className = 'option';

            const input = document.createElement('input');
            input.type = 'checkbox';
            input.name = 'question' + q.id;
            input.value = rep.valeur;

            label.appendChild(input);
            label.appendChild(document.createTextNode(rep.texte));
            divReponses.appendChild(label);
        });

        divQuestion.appendChild(divReponses);

        const explicationDiv = document.createElement('div');
        explicationDiv.className = 'explication';
        explicationDiv.id = 'explication' + q.id;
        explicationDiv.innerHTML = q.explication;
        divQuestion.appendChild(explicationDiv);

        form.appendChild(divQuestion);
    });
}

function verifier() {
    let score = 0;
    let totalQuestions = questions.length;

    questions.forEach(q => {
        const options = document.getElementsByName('question' + q.id);
        let bonneReponseCorrecte = true;
        let auMoinsUneReponse = false;

        for (let option of options) {
            if (option.checked) {
                auMoinsUneReponse = true;
                if (option.value !== 'correcte') {
                    bonneReponseCorrecte = false;
                }
            } else {
                if (option.value === 'correcte') {
                    bonneReponseCorrecte = false;
                }
            }
        }

        const divQuestion = document.getElementById('question' + q.id);
        const explicationDiv = document.getElementById('explication' + q.id);

        if (bonneReponseCorrecte && auMoinsUneReponse) {
            score++;
            divQuestion.classList.remove('incorrecte');
            explicationDiv.style.display = 'block';
            for (let option of options) {
                if (option.value === 'correcte') {
                    option.parentElement.classList.add('bonne-reponse');
                    option.parentElement.classList.remove('mauvaise-reponse');
                } else {
                    option.parentElement.classList.remove('bonne-reponse');
                }
            }
        } else {
            divQuestion.classList.add('incorrecte');
            explicationDiv.style.display = 'block';
            for (let option of options) {
                if (option.checked && option.value !== 'correcte') {
                    option.parentElement.classList.add('mauvaise-reponse');
                } else {
                    option.parentElement.classList.remove('mauvaise-reponse');
                }
                if (option.value === 'correcte') {
                    option.parentElement.classList.add('bonne-reponse');
                } else {
                    option.parentElement.classList.remove('bonne-reponse');
                }
            }
        }
    });

    const resultatDiv = document.getElementById('resultat');
    resultatDiv.textContent = `Votre score : ${score} / ${totalQuestions}`;
}

window.onload = afficherQuestions;
</script>

<section class="navigation">
    <a href="/sommaire.html" class="nav-btn">← Retour à l'accueil</a>
    <a href="quiz_01.html" class="nav-btn">← Quiz précédent</a>
    <a href="quiz_01.html" class="nav-btn">Quiz en anglais →</a>
    <a href="quiz_03.html" class="nav-btn">Quiz suivante →</a>
</section>

</body>
</html>
