
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Google Cloud - Associate Cloud Engineer Practice Exam</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f2f4f8;
            color: #333;
            max-width: 700px;
            margin: 30px auto;
            padding: 20px;
        }

        h2 {
            text-align: center;
            color: #2c3e50;
        }

        .question {
            background-color: #fff;
            padding: 15px 20px;
            margin-bottom: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s, background-color 0.3s;
        }

        .question:hover {
            transform: scale(1.02);
        }

        .question.incorrecte {
            background-color: #f8d7da;
        }

        .question p {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .option {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .option input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
        }

        .option.bonne-reponse {
            background-color: #d4edda;
        }

        .option.mauvaise-reponse {
            background-color: #f8d7da;
        }

        button {
            display: block;
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: 5px;
            cursor: pointer;
            margin: 20px auto;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .result {
            margin-top: 20px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
        }

        .navigation {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }

        .nav-btn {
            display: inline-block;
            background-color: #3498db;
            color: white;
            text-decoration: none;
            padding: 10px 10px;
            border-radius: 5px;
            font-size: 1em;
            transition: background-color 0.3s;
        }

        .nav-btn:hover {
            background-color: #2980b9;
        }

        .explication {
            white-space: pre-wrap;
            background-color: #eef3f7;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 10px;
            display: none;
        }

        .question img {
            max-width: 100%;
            margin-top: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<h2>Quiz : Google Cloud - Associate Cloud Engineer Practice Exam</h2>

<form id="quizForm"></form>

<button type="button" onclick="verifier()">Valider</button>

<div id="resultat" class="result"></div>

<script>
const questions = [
    {
        id: 1,
        texte: `Question 1: 
		An associate cloud engineer is working with Cloud Shell. What's the accurate description of Cloud Shell's persistence behavior?`,
        reponses: [
            { texte: "Cloud Shell provides a persistent 5GB home directory that remains across sessions.", valeur: "correcte" },
            { texte: "Cloud Shell instances persist indefinitely until they are manually stopped.", valeur: "mauvaise" },
            { texte: "Cloud Shell instances are ephemeral, and all changes including home directory modifications are lost after each session.", valeur: "mauvaise" },
            { texte: "Cloud Shell provides a persistent 1GB home directory that remains across sessions.", valeur: "mauvaise" }
        ],
        containerId: "reponses1",
        explication: `Cloud Shell provides a persistent 5GB home directory that remains across sessions. → Correct. Cloud Shell offers users a persistent 5GB home directory that is stored in Google Cloud Storage. This allows for the persistence of files across sessions.

Cloud Shell instances are ephemeral, and all changes including home directory modifications are lost after each session. → Incorrect. While it's true that Cloud Shell instances are ephemeral and automatically terminate after an hour of inactivity, the home directory in Cloud Shell is persistent and gets a 5GB allocation that remains across sessions.

Cloud Shell provides a persistent 1GB home directory that remains across sessions. → Incorrect. Cloud Shell provides a persistent 5GB home directory, not 1GB. This allocation allows you to store files and directories that can be accessed across different Cloud Shell sessions.

Cloud Shell instances persist indefinitely until they are manually stopped. → Incorrect. Cloud Shell sessions are ephemeral, meaning they only live for a short duration. Any session that remains inactive for an hour is automatically terminated.`
    },
    {
        id: 2,
        texte: `Question 2: 
		As a cloud engineer, you are tasked with creating an application that will require a large amount of ingress data for a sustained period of time. The application is hosted on a Compute Engine instance and you want to optimize for cost and performance. Which of the following strategies should you adopt to reserve an internal IP address for this task?`,
        reponses: [
            { texte: "Associate the instance with a regional static internal IP address and enable Direct Peering.", valeur: "correcte" },
            { texte: "Associate the instance with an ephemeral internal IP address only.", valeur: "mauvaise" },
            { texte: "Associate the instance with a static internal IP address only.", valeur: "mauvaise" },
            { texte: "Assign multiple ephemeral internal IP addresses to distribute the load.", valeur: "mauvaise" }
        ],
        containerId: "reponses2",
        explication: `Associate the instance with a regional static internal IP address and enable Direct Peering. → Correct. Associating the instance with a regional static internal IP address and enabling Direct Peering is the correct strategy. Direct Peering allows for large data volume transfers directly into and out of Google's network, thus reducing costs and latency.

Associate the instance with a static internal IP address only. → Incorrect. Just associating the instance with a static internal IP address only will not optimize for cost and performance when dealing with a large amount of ingress data for a sustained period.

Associate the instance with an ephemeral internal IP address only. → Incorrect. Associating the instance with an ephemeral internal IP address is not the best strategy as the IP address can change if the instance is stopped and restarted.

Assign multiple ephemeral internal IP addresses to distribute the load. → Incorrect. Assigning multiple ephemeral internal IP addresses to distribute the load is not possible. In GCP, you can only assign one internal IP address per network interface, and each VM instance can have multiple network interfaces, up to a maximum of 8.`
    },
		
		{
            id: 3,
            texte: `Question 3: 
			You are working on a project in Google Kubernetes Engine (GKE) where you are required to upgrade the version of Kubernetes in the node pools. You want to minimize disruptions to running applications during the process. Which of the following strategies should you employ?`,
            reponses: [
                { texte: "Create a new node pool with the desired Kubernetes version and migrate workloads gradually.", valeur: "correcte" },
                { texte: "Make no changes and rely on the automatic upgrades provided by GKE.", valeur: "mauvaise" },
                { texte: "Use rolling updates by setting the maxUnavailable parameter to a high value.", valeur: "mauvaise" },
                { texte: "Manually terminate all the pods before performing the upgrade.", valeur: "mauvaise" }
            ],
            containerId: "reponses3",
            explication: `Create a new node pool with the desired Kubernetes version and migrate workloads gradually. → Correct. Creating a new node pool with the desired Kubernetes version and gradually migrating workloads is the best approach. This strategy enables you to test your workloads against the new Kubernetes version without disturbing running applications. Once the new node pool is verified to work as expected, you can gradually shift your workloads to the new node pool and decommission the old one.

Manually terminate all the pods before performing the upgrade. → Incorrect. Manually terminating all the pods before performing the upgrade is incorrect because it would cause a disruption to running applications. Applications should ideally never experience downtime due to Kubernetes upgrades.

Use rolling updates by setting the maxUnavailable parameter to a high value. → Incorrect. While it's true that GKE supports rolling updates, setting the maxUnavailable parameter to a high value would potentially cause disruptions to running applications. Rolling updates should ideally proceed slowly, with only a small fraction of pods being unavailable at any time.

Make no changes and rely on the automatic upgrades provided by GKE. → Incorrect. Relying on automatic upgrades is not the best approach if you want to minimize disruptions to running applications. Automatic upgrades can be unpredictable and could potentially cause downtime if something goes wrong. A controlled, gradual upgrade process provides more safety.`
        },
		
		{
            id: 4,
            texte: `Question 4: 
			As a associate engineer, you are tasked with the management of a Compute Engine instance that needs to be configured to automatically restart if it becomes unresponsive due to system errors. Which of the following configurations should you select for the instance?`,
            reponses: [
                { texte: `Set the instance's "Automatic restart" setting to "On".`, valeur: "correcte" },
                { texte: `Set the instance's "On host maintenance" setting to "Terminate instance".`, valeur: "mauvaise" },
                { texte: `Set the instance's "Deletion protection" setting to "On".`, valeur: "mauvaise" },
                { texte: `Set the instance's "Preemptibility" setting to "On".`, valeur: "mauvaise" }
            ],
            containerId: "reponses1",
            explication: `Set the instance's "Automatic restart" setting to "On". → Correct. 
	If the instance's Automatic restart setting is enabled, Compute Engine will automatically reboot the instance if it crashes due to a system error.

Set the instance's "On host maintenance" setting to "Terminate instance". → Incorrect. 
	This setting determines what happens when the physical host where the instance resides undergoes maintenance, not when the instance itself experiences system errors.

Set the instance's "Preemptibility" setting to "On". → Incorrect. 
	The Preemptibility setting determines whether an instance is preemptible, which means it can be stopped by Google Cloud if resources are needed elsewhere. It doesn't control whether the instance will restart automatically if it crashes.

Set the instance's "Deletion protection" setting to "On". → Incorrect. 
	Deletion protection prevents the instance from being deleted, but it doesn't control what happens if the instance crashes.`
        }
		// Ajoute les autres questions avec leurs explications ici...
];

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function afficherQuestions() {
    const form = document.getElementById('quizForm');
    form.innerHTML = '';

    questions.forEach(q => {
        const divQuestion = document.createElement('div');
        divQuestion.className = 'question';
        divQuestion.id = 'question' + q.id;

        const pQuestion = document.createElement('p');
        pQuestion.textContent = q.texte;
        divQuestion.appendChild(pQuestion);

        if (q.image) {
            const img = document.createElement('img');
            img.src = q.image;
            img.alt = 'Illustration';
            divQuestion.appendChild(img);
        }

        const divReponses = document.createElement('div');
        divReponses.id = q.containerId;

        const reponsesMelangees = [...q.reponses];
        shuffle(reponsesMelangees);

        reponsesMelangees.forEach(rep => {
            const label = document.createElement('label');
            label.className = 'option';

            const input = document.createElement('input');
            input.type = 'checkbox';
            input.name = 'question' + q.id;
            input.value = rep.valeur;

            label.appendChild(input);
            label.appendChild(document.createTextNode(rep.texte));
            divReponses.appendChild(label);
        });

        divQuestion.appendChild(divReponses);

        const explicationDiv = document.createElement('div');
        explicationDiv.className = 'explication';
        explicationDiv.id = 'explication' + q.id;
        explicationDiv.innerHTML = q.explication;
        divQuestion.appendChild(explicationDiv);

        form.appendChild(divQuestion);
    });
}

function verifier() {
    let score = 0;
    let totalQuestions = questions.length;

    questions.forEach(q => {
        const options = document.getElementsByName('question' + q.id);
        let bonneReponseCorrecte = true;
        let auMoinsUneReponse = false;

        for (let option of options) {
            if (option.checked) {
                auMoinsUneReponse = true;
                if (option.value !== 'correcte') {
                    bonneReponseCorrecte = false;
                }
            } else {
                if (option.value === 'correcte') {
                    bonneReponseCorrecte = false;
                }
            }
        }

        const divQuestion = document.getElementById('question' + q.id);
        const explicationDiv = document.getElementById('explication' + q.id);

        if (bonneReponseCorrecte && auMoinsUneReponse) {
            score++;
            divQuestion.classList.remove('incorrecte');
            explicationDiv.style.display = 'block';
            for (let option of options) {
                if (option.value === 'correcte') {
                    option.parentElement.classList.add('bonne-reponse');
                    option.parentElement.classList.remove('mauvaise-reponse');
                } else {
                    option.parentElement.classList.remove('bonne-reponse');
                }
            }
        } else {
            divQuestion.classList.add('incorrecte');
            explicationDiv.style.display = 'block';
            for (let option of options) {
                if (option.checked && option.value !== 'correcte') {
                    option.parentElement.classList.add('mauvaise-reponse');
                } else {
                    option.parentElement.classList.remove('mauvaise-reponse');
                }
                if (option.value === 'correcte') {
                    option.parentElement.classList.add('bonne-reponse');
                } else {
                    option.parentElement.classList.remove('bonne-reponse');
                }
            }
        }
    });

    const resultatDiv = document.getElementById('resultat');
    resultatDiv.textContent = `Votre score : ${score} / ${totalQuestions}`;
}

window.onload = afficherQuestions;
</script>

<section class="navigation">
    <a href="/sommaire.html" class="nav-btn">← Retour à l'accueil</a>
    <a href="quiz_01.html" class="nav-btn">← Quiz précédent</a>
    <a href="quiz_01.html" class="nav-btn">Quiz en anglais →</a>
    <a href="quiz_03.html" class="nav-btn">Quiz suivante →</a>
</section>

</body>
</html>
